# Pydantic models for Domain Events
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any # Added Dict, Any
import datetime
import uuid

# Re-importing PersonData from its new location for use in event payloads if needed
from case_management_service.infrastructure.kafka.schemas import PersonData, AddressData # AddressData for CompanyProfileEventPayload

class EventMetaData(BaseModel):
    correlation_id: Optional[str] = None
    causation_id: Optional[str] = None

class BaseEvent(BaseModel):
    event_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    event_type: str
    aggregate_id: str
    timestamp: datetime.datetime = Field(default_factory=datetime.datetime.utcnow)
    version: int = 1
    payload: BaseModel # Payload is a Pydantic model for type safety
    metadata: EventMetaData = Field(default_factory=EventMetaData)
    payload_model_name: Optional[str] = None # Hint for deserialization

# --- Existing Event Payloads - Modifications ---
class CaseCreatedEventPayload(BaseModel):
    client_id: str
    case_type: str # Corresponds to 'type' from KafkaMessage/CreateCaseCommand
    case_version: str # Corresponds to 'version'
    traitement_type: str # New: "KYC" or "KYB"
    # Optional: Link to a company if a company was created as part of this case context
    company_id: Optional[str] = None

# --- New Domain Event Payloads & Events ---

# Company Profile Events
class CompanyProfileEventPayloadStructure(BaseModel): # Define structure once
    registered_name: str
    trading_name: Optional[str] = None
    registration_number: str
    registration_date: Optional[str] = None
    country_of_incorporation: str
    registered_address: AddressData # Re-use AddressData from kafka.schemas
    business_type: Optional[str] = None
    industry_sector: Optional[str] = None
    # client_id: Optional[str] = None # If company can be linked to a client context separate from case

class CompanyProfileCreatedEventPayload(CompanyProfileEventPayloadStructure):
    pass

class CompanyProfileCreatedEvent(BaseEvent):
    event_type: str = "CompanyProfileCreated"
    payload: CompanyProfileCreatedEventPayload
    payload_model_name: str = "CompanyProfileCreatedEventPayload"

# Beneficial Owner Events
class BeneficialOwnerEventPayloadStructure(BaseModel):
    person_details: PersonData
    ownership_percentage: Optional[float] = None
    types_of_control: Optional[List[str]] = Field(default_factory=list)
    is_ubo: bool = False

class BeneficialOwnerAddedEventPayload(BeneficialOwnerEventPayloadStructure):
    beneficial_owner_id: str
    # company_id is the aggregate_id of the event

class BeneficialOwnerAddedEvent(BaseEvent):
    event_type: str = "BeneficialOwnerAdded"
    payload: BeneficialOwnerAddedEventPayload
    payload_model_name: str = "BeneficialOwnerAddedEventPayload"

# Person Event Modifications/Additions
class PersonAddedToCaseEventPayload(BaseModel):
    person_id: str
    firstname: str
    lastname: str
    birthdate: Optional[str]

class PersonLinkedToCompanyEventPayload(BaseModel):
    person_id: str
    firstname: str
    lastname: str
    birthdate: Optional[str]
    role_in_company: str

class PersonLinkedToCompanyEvent(BaseEvent):
    event_type: str = "PersonLinkedToCompany"
    payload: PersonLinkedToCompanyEventPayload
    payload_model_name: str = "PersonLinkedToCompanyEventPayload"

# --- Existing Events - Ensure they use the updated BaseEvent and payloads ---
class CaseCreatedEvent(BaseEvent):
    event_type: str = "CaseCreated"
    payload: CaseCreatedEventPayload
    payload_model_name: str = "CaseCreatedEventPayload"

class PersonAddedToCaseEvent(BaseEvent):
    event_type: str = "PersonAddedToCase"
    payload: PersonAddedToCaseEventPayload
    payload_model_name: str = "PersonAddedToCaseEventPayload"

# --- Document Requirement Domain Event Payloads & Events ---

class DocumentRequirementDeterminedEventPayload(BaseModel):
    case_id: str
    entity_id: str # person_id or company_id
    entity_type: str # "PERSON" or "COMPANY"
    document_type: str
    is_required: bool
    # document_requirement_id will be generated by the projector/read_model when creating RequiredDocumentDB

class DocumentRequirementDeterminedEvent(BaseEvent):
    event_type: str = "DocumentRequirementDetermined"
    payload: DocumentRequirementDeterminedEventPayload
    payload_model_name: str = "DocumentRequirementDeterminedEventPayload"
    # aggregate_id could be case_id or entity_id. Let's use case_id to group doc requirements under a case.

class DocumentStatusUpdatedEventPayload(BaseModel):
    document_requirement_id: str # The ID of the RequiredDocumentDB entry
    new_status: str
    old_status: str # For context
    updated_by: Optional[str] = None # System user or actual user ID
    metadata_update: Optional[Dict[str, Any]] = None
    notes_added: Optional[List[str]] = None

class DocumentStatusUpdatedEvent(BaseEvent):
    event_type: str = "DocumentStatusUpdated"
    payload: DocumentStatusUpdatedEventPayload
    payload_model_name: str = "DocumentStatusUpdatedEventPayload"
    # aggregate_id here should be document_requirement_id as it's the subject of the change.
